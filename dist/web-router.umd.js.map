{"version":3,"file":"web-router.umd.js","sources":["../src/index.js"],"sourcesContent":["'use strict';\n\n/**\n  See README.md and __tests__/src/index.test.js\n*/\n\nimport _ from 'lodash';\n\nlet _routes = {};\nlet DEBUG = false;\nlet autoListen = true;\nlet lastResolved = null;\nconst pageLinkDefaultNames = ['[data-navigo]', '[data-route]']\nlet pageLinkNames = pageLinkDefaultNames.slice(0);\nlet notFoundHandler = null;\n/**\n  @param {array} items - an array of functions to recursively call\n  @param {object} params\n  @param {function} callback\n\n  helper method to handle an array of functions\n*/\nfunction recursionMethods(items, params=null, callback) {\n  if(!items.length) { return callback(true); }\n  const first = _.head(items);\n  if(_.isFunction(first)) {\n    first((allow=true)=>{\n      if(!allow) { return callback(false); }\n      recursionMethods(_.tail(items), params, callback);\n    });\n  }\n}\n\n/**\n  @param {string} hookType - before, after or leave\n  @param {RouteInfo} route object\n  @param {object} params\n  @param {function} callback\n\n  Pass the callback through\n*/\nfunction callHook(hookType, info, params=null, callback=()=>{}) {\n  if(_.isFunction(info.hooks[hookType])) {\n    info.hooks[hookType]((allow=true)=>{\n      if(allow) { callback(allow) }\n    }, params);\n  } else if(_.isArray(info.hooks[hookType])) {\n    recursionMethods(info.hooks[hookType], params, (allow=true)=>{\n      if(allow) { callback(allow); }\n    });\n  } else {\n    callback();\n  }\n}\n/**\n  @param {RouteInfo} info - the value matched from _routes\n  @param {object|array|null} - route matching\n*/\nfunction callBeforeAndMain(info, params=null) {\n  return callHook('before', info, params, (allow)=>{\n    if(_.isArray(params)) {\n      info.method.apply({}, params);\n    } else {\n      info.method(params);\n    }\n  });\n}\n/**\n  @param {RouteInfo} info - the value matched from _routes\n  @param {object|array|null} - route matching\n  @param {function} callback - method to call when completed. \n*/\nfunction callAfter(info, params=null, callback=(allow)=>{}) {\n  return callHook('after', info, params, callback);\n}\n\n/**\n  @param {RouteInfo} info - the value matched from _routes\n  @param {object|array|null} - route matching\n  @param {function} callback - method to call when completed. \n*/\nfunction callLeave(info, params=null, callback=(allow)=>{}) {\n  return callHook('leave', info, params, callback);\n}\n\n/**\n  @param {Event} evt - the window popstate event\n\n  @return {WebRouter}\n*/\nfunction locationChange(evt) {\n  if(lastResolved) {\n    if(DEBUG) console.log(\"was a last resolve\", lastResolved);\n    callLeave(lastResolved, evt);\n  }\n  this.resolve();\n  return this;\n}\n\n/**\n  Formalize the route information\n*/\nfunction RouteInfo(props) {\n  Object.assign(this, props);\n  return this;\n}\n\n/**\n  A WebRouter that works with `popstate`\n  @class \n*/\nexport class WebRouter {\n  constructor(routes={}) {\n    lastResolved = null;\n    for(const key in routes) {\n      const value = routes[key];\n      this.on(key, value);\n    }    \n    if(autoListen) {\n      this.listen();\n      this.updatePageLinks();\n    }\n  }\n  /**\n    @param {string|RegExp} routeName\n    @param {function} method\n    @param {object} hooks of format {before, after, leave}\n\n    @return {WebRouter}\n  */\n  on(routeName='/', method, hooks={}) {\n    if(DEBUG) console.log(\".on(\", routeName, method, hooks, \")\");\n    let name = routeName;\n    let isRegExp = false;\n    const keys = [];\n    if(_.isRegExp(routeName)) {\n      isRegExp = true;\n      name = routeName.toString();\n    } else {\n      // handle parameterized URL string\n      const remapped = name.split('/').map(item=>{\n        if(item.startsWith(\":\")) {\n          isRegExp = true;\n          keys.push(item.slice(1));\n          return '([^/]{1,})';\n        }\n        return item;\n      });\n      routeName = new RegExp('^' + remapped.join('/') + '$');\n    }\n    _routes[name] = new RouteInfo({\n      name,\n      regExp:isRegExp ? routeName : null,\n      regExpKeys:keys,\n      method,\n      hooks\n    });\n    return this;   \n  } \n  /**\n    @return {WebRouter}\n  */\n  off(...args) {\n    if(DEBUG) { console.log(\".off(\", args, \")\"); }\n    if(args.length === 0) {\n      WebRouter.reset();\n      window.removeEventListener('popstate', locationChange.bind(this), false);\n      delete window.hasListenerAttached;\n    } else {\n      const [routeName] = args;\n      delete _routes[routeName];  \n    }\n    return this;\n  }\n  /**\n    @return {WebRouter}\n  */  \n  listen() {\n    if(!window.hasListenerAttached) {\n      if(DEBUG) console.log(\"listen() Attaching to window\")\n      window.addEventListener('popstate', locationChange.bind(this), false);\n      window.hasListenerAttached = true;      \n    }\n    return this;\n  }\n  /**\n    @param {function} callback (optional) used mostly for testing\n\n    @return {WebRouter}\n  */\n  updatePageLinks(callback=null) {\n    if(DEBUG) console.log('updatePageLinks', pageLinkNames);\n    pageLinkNames.forEach(name=>{\n      const links = document.querySelectorAll(name);\n      _.forEach(links, el=>{\n        if(!el.hasListenerAttached) {\n          el.addEventListener('click', (evt)=>{\n            if(DEBUG) { \n              console.log(\"CLICKED. Now navigate\", evt); \n            }\n            if((evt.ctrlKey || evt.metaKey) && evt.target.tagName.toLowerCase() === 'a') { \n              return false; \n            }\n            evt.preventDefault();\n            const href = evt.target.getAttribute('href');\n            if(!callback) {\n              this.navigate(href);\n            } else {\n              callback.call(this, href);  \n            }\n          }, false);\n        }\n        el.hasListenerAttached = true;\n      });\n    });\n    return this;\n  }\n  /**\n    @param {string} path - the path to navigate\n    @param {object} data - an object to set for `state`\n\n    @return {WebRouter}\n  */\n  navigate(path, data=null) {\n    window.history.pushState(data, null, path);\n    this.resolve();\n    return this;\n  }\n  /**\n    @return {WebRouter}\n  */\n  notFound(handler) {\n    if(_.isFunction(handler)) {\n      notFoundHandler = handler;  \n    }\n    return this;\n  }\n  /**\n    @param {string} current (optional) - default is current window.location.pathname. \n\n    @return {WebRouter}\n  */\n  resolve(current=window.location.pathname) {\n    if(DEBUG) console.log('Resolve', current);\n    let wasMatched = false;\n    for(const key in _routes) {\n      const value = _routes[key];\n      if(!value.regExp) {\n        if(key === current) {\n          wasMatched = true;\n          lastResolved = value;\n          callBeforeAndMain(value, {});\n          callAfter(value, null);\n        }\n      } else if(value.regExp) {\n        const matched = current.match(value.regExp) || [];\n        const keyMatches = matched.slice(1, value.regExpKeys.length+1);\n        const raw = {};\n        if(matched && matched.length) {\n          keyMatches.forEach((item, idx)=>{\n            const key = value.regExpKeys[idx];\n            raw[key] = item;\n          });\n          const params = value.regExpKeys.length ? raw : matched.slice(1);\n          wasMatched = true;\n          lastResolved = value;\n          callBeforeAndMain(value, params);\n          callAfter(value, params);\n        }\n      }\n    }\n    if(!wasMatched) {\n      lastResolved = null;\n      if(notFoundHandler) {\n        if(DEBUG) console.log(\"notFound\");\n        notFoundHandler.call(this);\n      }\n    } else if(DEBUG) {\n      console.log('Route Matched', lastResolved);\n    }\n    return this;\n  }\n  /**\n    @return {object}\n  */\n  get all() {\n    return _routes;\n  }\n\n  static set autoListen(value) {\n    return autoListen = !!(value);\n  }\n  /**\n    @return {object}\n  */  \n  static get routes() {\n    return _routes;\n  }\n  /**\n    @return {string}\n  */\n  static get lastResolved() {\n    return lastResolved;\n  }\n  static reset() {\n    _routes = {}\n    autoListen = true;\n    lastResolved = null;\n    notFoundHandler = null;\n    pageLinkNames = pageLinkDefaultNames.slice(0);\n  } \n  static set debug(value) {\n    DEBUG = !!(value);\n  }\n  /**\n    @param {array} items - additional selectors to use when calling `.updatePageLinks()`\n  */\n  static addPageLinkSelectors(items=[]) {\n    pageLinkNames.push(...items);\n    pageLinkNames = _.unique(pageLinkNames)\n  }\n}\n"],"names":["_routes","DEBUG","autoListen","lastResolved","pageLinkDefaultNames","pageLinkNames","slice","notFoundHandler","callHook","hookType","info","params","callback","_","isFunction","hooks","allow","isArray","recursionMethods","items","length","first","head","tail","callBeforeAndMain","method","apply","callAfter","locationChange","evt","console","log","this","resolve","RouteInfo","props","Object","assign","routes","key","on","listen","updatePageLinks","routeName","name","isRegExp","keys","toString","remapped","split","map","item","startsWith","push","RegExp","join","regExp","regExpKeys","off","args","WebRouter","reset","window","removeEventListener","bind","hasListenerAttached","addEventListener","forEach","links","document","querySelectorAll","el","ctrlKey","metaKey","target","tagName","toLowerCase","preventDefault","href","getAttribute","call","_this","navigate","path","data","history","pushState","notFound","handler","current","location","pathname","wasMatched","value","matched","match","keyMatches","raw","idx","addPageLinkSelectors","unique"],"mappings":"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"}