{"version":3,"file":"web-router.modern.js","sources":["../src/index.js"],"sourcesContent":["'use strict';\n\n/**\n  See README.md and __tests__/src/index.test.js\n*/\n\nimport _ from 'lodash';\n\nlet _routes = {};\nlet DEBUG = false;\nlet autoListen = true;\nlet lastResolved = null;\nconst pageLinkDefaultNames = ['[data-navigo]', '[data-route]']\nlet pageLinkNames = pageLinkDefaultNames.slice(0);\nlet notFoundHandler = null;\n/**\n  @param {array} items - an array of functions to recursively call\n  @param {object} params\n  @param {function} callback\n\n  helper method to handle an array of functions\n*/\nfunction recursionMethods(items, params=null, callback) {\n  if(!items.length) { return callback(true); }\n  const first = _.head(items);\n  if(_.isFunction(first)) {\n    first((allow=true)=>{\n      if(!allow) { return callback(false); }\n      recursionMethods(_.tail(items), params, callback);\n    });\n  }\n}\n\n/**\n  @param {string} hookType - before, after or leave\n  @param {RouteInfo} route object\n  @param {object} params\n  @param {function} callback\n\n  Pass the callback through\n*/\nfunction callHook(hookType, info, params=null, callback=()=>{}) {\n  if(_.isFunction(info.hooks[hookType])) {\n    info.hooks[hookType]((allow=true)=>{\n      if(allow) { callback(allow) }\n    }, params);\n  } else if(_.isArray(info.hooks[hookType])) {\n    recursionMethods(info.hooks[hookType], params, (allow=true)=>{\n      if(allow) { callback(allow); }\n    });\n  } else {\n    callback();\n  }\n}\n/**\n  @param {RouteInfo} info - the value matched from _routes\n  @param {object|array|null} - route matching\n*/\nfunction callBeforeAndMain(info, params=null) {\n  return callHook('before', info, params, (allow)=>{\n    if(_.isArray(params)) {\n      info.method.apply({}, params);\n    } else {\n      info.method(params);\n    }\n  });\n}\n/**\n  @param {RouteInfo} info - the value matched from _routes\n  @param {object|array|null} - route matching\n  @param {function} callback - method to call when completed. \n*/\nfunction callAfter(info, params=null, callback=(allow)=>{}) {\n  return callHook('after', info, params, callback);\n}\n\n/**\n  @param {RouteInfo} info - the value matched from _routes\n  @param {object|array|null} - route matching\n  @param {function} callback - method to call when completed. \n*/\nfunction callLeave(info, params=null, callback=(allow)=>{}) {\n  return callHook('leave', info, params, callback);\n}\n\n/**\n  @param {Event} evt - the window popstate event\n\n  @return {WebRouter}\n*/\nfunction locationChange(evt) {\n  if(lastResolved) {\n    if(DEBUG) console.log(\"was a last resolve\", lastResolved);\n    callLeave(lastResolved, evt);\n  }\n  this.resolve();\n  return this;\n}\n\n/**\n  Formalize the route information\n*/\nfunction RouteInfo(props) {\n  Object.assign(this, props);\n  return this;\n}\n\n/**\n  A WebRouter that works with `popstate`\n  @class \n*/\nexport class WebRouter {\n  constructor(routes={}) {\n    lastResolved = null;\n    for(const key in routes) {\n      const value = routes[key];\n      this.on(key, value);\n    }    \n    if(autoListen) {\n      this.listen();\n      this.updatePageLinks();\n    }\n  }\n  /**\n    @param {string|RegExp} routeName\n    @param {function} method\n    @param {object} hooks of format {before, after, leave}\n\n    @return {WebRouter}\n  */\n  on(routeName='/', method, hooks={}) {\n    if(DEBUG) console.log(\".on(\", routeName, method, hooks, \")\");\n    let name = routeName;\n    let isRegExp = false;\n    const keys = [];\n    if(_.isRegExp(routeName)) {\n      isRegExp = true;\n      name = routeName.toString();\n    } else {\n      // handle parameterized URL string\n      const remapped = name.split('/').map(item=>{\n        if(item.startsWith(\":\")) {\n          isRegExp = true;\n          keys.push(item.slice(1));\n          return '([^/]{1,})';\n        }\n        return item;\n      });\n      routeName = new RegExp('^' + remapped.join('/') + '$');\n    }\n    _routes[name] = new RouteInfo({\n      name,\n      regExp:isRegExp ? routeName : null,\n      regExpKeys:keys,\n      method,\n      hooks\n    });\n    return this;   \n  } \n  /**\n    @return {WebRouter}\n  */\n  off(...args) {\n    if(DEBUG) { console.log(\".off(\", args, \")\"); }\n    if(args.length === 0) {\n      WebRouter.reset();\n      window.removeEventListener('popstate', locationChange.bind(this), false);\n      delete window.hasListenerAttached;\n    } else {\n      const [routeName] = args;\n      delete _routes[routeName];  \n    }\n    return this;\n  }\n  /**\n    @return {WebRouter}\n  */  \n  listen() {\n    if(!window.hasListenerAttached) {\n      if(DEBUG) console.log(\"listen() Attaching to window\")\n      window.addEventListener('popstate', locationChange.bind(this), false);\n      window.hasListenerAttached = true;      \n    }\n    return this;\n  }\n  /**\n    @param {function} callback (optional) used mostly for testing\n\n    @return {WebRouter}\n  */\n  updatePageLinks(callback=null) {\n    if(DEBUG) console.log('updatePageLinks', pageLinkNames);\n    pageLinkNames.forEach(name=>{\n      const links = document.querySelectorAll(name);\n      _.forEach(links, el=>{\n        if(!el.hasListenerAttached) {\n          el.addEventListener('click', (evt)=>{\n            if(DEBUG) { \n              console.log(\"CLICKED. Now navigate\", evt); \n            }\n            if((evt.ctrlKey || evt.metaKey) && evt.target.tagName.toLowerCase() === 'a') { \n              return false; \n            }\n            evt.preventDefault();\n            const href = evt.target.getAttribute('href');\n            if(!callback) {\n              this.navigate(href);\n            } else {\n              callback.call(this, href);  \n            }\n          }, false);\n        }\n        el.hasListenerAttached = true;\n      });\n    });\n    return this;\n  }\n  /**\n    @param {string} path - the path to navigate\n    @param {object} data - an object to set for `state`\n\n    @return {WebRouter}\n  */\n  navigate(path, data=null) {\n    window.history.pushState(data, null, path);\n    this.resolve();\n    return this;\n  }\n  /**\n    @return {WebRouter}\n  */\n  notFound(handler) {\n    if(_.isFunction(handler)) {\n      notFoundHandler = handler;  \n    }\n    return this;\n  }\n  /**\n    @param {string} current (optional) - default is current window.location.pathname. \n\n    @return {WebRouter}\n  */\n  resolve(current=window.location.pathname) {\n    if(DEBUG) console.log('Resolve', current);\n    let wasMatched = false;\n    for(const key in _routes) {\n      const value = _routes[key];\n      if(!value.regExp) {\n        if(key === current) {\n          wasMatched = true;\n          lastResolved = value;\n          callBeforeAndMain(value, {});\n          callAfter(value, null);\n        }\n      } else if(value.regExp) {\n        const matched = current.match(value.regExp) || [];\n        const keyMatches = matched.slice(1, value.regExpKeys.length+1);\n        const raw = {};\n        if(matched && matched.length) {\n          keyMatches.forEach((item, idx)=>{\n            const key = value.regExpKeys[idx];\n            raw[key] = item;\n          });\n          const params = value.regExpKeys.length ? raw : matched.slice(1);\n          wasMatched = true;\n          lastResolved = value;\n          callBeforeAndMain(value, params);\n          callAfter(value, params);\n        }\n      }\n    }\n    if(!wasMatched) {\n      lastResolved = null;\n      if(notFoundHandler) {\n        if(DEBUG) console.log(\"notFound\");\n        notFoundHandler.call(this);\n      }\n    } else if(DEBUG) {\n      console.log('Route Matched', lastResolved);\n    }\n    return this;\n  }\n  /**\n    @return {object}\n  */\n  get all() {\n    return _routes;\n  }\n\n  static set autoListen(value) {\n    return autoListen = !!(value);\n  }\n  /**\n    @return {object}\n  */  \n  static get routes() {\n    return _routes;\n  }\n  /**\n    @return {string}\n  */\n  static get lastResolved() {\n    return lastResolved;\n  }\n  static reset() {\n    _routes = {}\n    autoListen = true;\n    lastResolved = null;\n    notFoundHandler = null;\n    pageLinkNames = pageLinkDefaultNames.slice(0);\n  } \n  static set debug(value) {\n    DEBUG = !!(value);\n  }\n  /**\n    @param {array} items - additional selectors to use when calling `.updatePageLinks()`\n  */\n  static addPageLinkSelectors(items=[]) {\n    pageLinkNames.push(...items);\n    pageLinkNames = _.unique(pageLinkNames)\n  }\n}\n"],"names":["_routes","DEBUG","autoListen","lastResolved","pageLinkDefaultNames","pageLinkNames","slice","notFoundHandler","callHook","hookType","info","params","callback","_","isFunction","hooks","allow","isArray","recursionMethods","items","length","first","head","tail","callBeforeAndMain","method","apply","callAfter","locationChange","evt","console","log","callLeave","this","resolve","RouteInfo","props","Object","assign","WebRouter","constructor","routes","key","on","listen","updatePageLinks","routeName","name","isRegExp","keys","toString","remapped","split","map","item","startsWith","push","RegExp","join","regExp","regExpKeys","off","args","reset","window","removeEventListener","bind","hasListenerAttached","addEventListener","forEach","links","document","querySelectorAll","el","ctrlKey","metaKey","target","tagName","toLowerCase","preventDefault","href","getAttribute","call","navigate","path","data","history","pushState","notFound","handler","current","location","pathname","wasMatched","value","matched","match","keyMatches","raw","idx","all","[object Object]","debug","unique"],"mappings":"sBAQA,IAAIA,EAAU,GACVC,GAAQ,EACRC,GAAa,EACbC,EAAe,KACnB,MAAMC,EAAuB,CAAC,gBAAiB,gBAC/C,IAAIC,EAAgBD,EAAqBE,MAAM,GAC3CC,EAAkB,KA2BtB,SAASC,EAASC,EAAUC,EAAMC,EAAO,KAAMC,EAAS,UACnDC,EAAEC,WAAWJ,EAAKK,MAAMN,IACzBC,EAAKK,MAAMN,GAAU,CAACO,GAAM,KACvBA,GAASJ,EAASI,IACpBL,GACKE,EAAEI,QAAQP,EAAKK,MAAMN,IAxBjC,SAASS,EAAiBC,EAAOR,EAAO,KAAMC,GAC5C,IAAIO,EAAMC,OAAU,OAAOR,GAAS,GACpC,MAAMS,EAAQR,EAAES,KAAKH,GAClBN,EAAEC,WAAWO,IACdA,EAAM,CAACL,GAAM,KACX,IAAIA,EAAS,OAAOJ,GAAS,GAC7BM,EAAiBL,EAAEU,KAAKJ,GAAQR,EAAQC,KAmB1CM,CAAiBR,EAAKK,MAAMN,GAAWE,EAAQ,CAACK,GAAM,KACjDA,GAASJ,EAASI,KAGvBJ,IAOJ,SAASY,EAAkBd,EAAMC,EAAO,MACtC,OAAOH,EAAS,SAAUE,EAAMC,EAASK,IACpCH,EAAEI,QAAQN,GACXD,EAAKe,OAAOC,MAAM,GAAIf,GAEtBD,EAAKe,OAAOd,KASlB,SAASgB,EAAUjB,EAAMC,EAAO,KAAMC,EAAUI,CAAAA,QAC9C,OAAOR,EAAS,QAASE,EAAMC,EAAQC,GAiBzC,SAASgB,EAAeC,GAMtB,OALG1B,IACEF,GAAO6B,QAAQC,IAAI,qBAAsB5B,GAXhD,SAAmBO,EAAMC,EAAO,KAAMC,EAAUI,CAAAA,QACvCR,EAAS,QAWJL,EAXmBQ,EAAQC,GAWrCoB,CAAU7B,EAAc0B,IAE1BI,KAAKC,eAOP,SAASC,EAAUC,GAEjB,OADAC,OAAOC,OAAOL,KAAMG,cAQTG,EACXC,YAAYC,EAAO,IACjBtC,EAAe,KACf,IAAI,MAAMuC,KAAOD,EAEfR,KAAKU,GAAGD,EADMD,EAAOC,IAGpBxC,IACD+B,KAAKW,SACLX,KAAKY,mBAUTF,GAAGG,EAAU,IAAKrB,EAAQV,EAAM,IAC3Bd,GAAO6B,QAAQC,IAAI,OAAQe,EAAWrB,EAAQV,EAAO,KACxD,IAAIgC,EAAOD,EACPE,GAAW,EACf,MAAMC,EAAO,GACb,GAAGpC,EAAEmC,SAASF,GACZE,GAAW,EACXD,EAAOD,EAAUI,eACZ,CAEL,MAAMC,EAAWJ,EAAKK,MAAM,KAAKC,IAAIC,GAChCA,EAAKC,WAAW,MACjBP,GAAW,EACXC,EAAKO,KAAKF,EAAKhD,MAAM,IACd,cAEFgD,GAETR,EAAY,IAAIW,OAAO,IAAMN,EAASO,KAAK,KAAO,KASpD,OAPA1D,EAAQ+C,GAAQ,IAAIZ,EAAU,CAC5BY,KAAAA,EACAY,OAAOX,EAAWF,EAAY,KAC9Bc,WAAWX,EACXxB,OAAAA,EACAV,MAAAA,SAOJ8C,OAAOC,GAEL,GADG7D,GAAS6B,QAAQC,IAAI,QAAS+B,EAAM,KACpB,IAAhBA,EAAK1C,OACNmB,EAAUwB,QACVC,OAAOC,oBAAoB,WAAYrC,EAAesC,KAAKjC,OAAO,UAC3D+B,OAAOG,wBACT,CACL,MAAOrB,GAAagB,SACb9D,EAAQ8C,GAEjB,YAKFF,SAME,OALIoB,OAAOG,sBACNlE,GAAO6B,QAAQC,IAAI,gCACtBiC,OAAOI,iBAAiB,WAAYxC,EAAesC,KAAKjC,OAAO,GAC/D+B,OAAOG,qBAAsB,QASjCtB,gBAAgBjC,EAAS,MAyBvB,OAxBGX,GAAO6B,QAAQC,IAAI,kBAAmB1B,GACzCA,EAAcgE,QAAQtB,IACpB,MAAMuB,EAAQC,SAASC,iBAAiBzB,GACxClC,EAAEwD,QAAQC,EAAOG,IACXA,EAAGN,qBACLM,EAAGL,iBAAiB,QAAUvC,IAI5B,GAHG5B,GACD6B,QAAQC,IAAI,wBAAyBF,IAEnCA,EAAI6C,SAAW7C,EAAI8C,UAAiD,MAArC9C,EAAI+C,OAAOC,QAAQC,cACpD,SAEFjD,EAAIkD,iBACJ,MAAMC,EAAOnD,EAAI+C,OAAOK,aAAa,QACjCrE,EAGFA,EAASsE,KAAKjD,KAAM+C,GAFpB/C,KAAKkD,SAASH,KAIf,GAELP,EAAGN,qBAAsB,WAW/BgB,SAASC,EAAMC,EAAK,MAGlB,OAFArB,OAAOsB,QAAQC,UAAUF,EAAM,KAAMD,GACrCnD,KAAKC,eAMPsD,SAASC,GAIP,OAHG5E,EAAEC,WAAW2E,KACdlF,EAAkBkF,QAStBvD,QAAQwD,EAAQ1B,OAAO2B,SAASC,UAC3B3F,GAAO6B,QAAQC,IAAI,UAAW2D,GACjC,IAAIG,GAAa,EACjB,IAAI,MAAMnD,KAAO1C,EAAS,CACxB,MAAM8F,EAAQ9F,EAAQ0C,GACtB,GAAIoD,EAAMnC,WAOAmC,EAAMnC,OAAQ,CACtB,MAAMoC,EAAUL,EAAQM,MAAMF,EAAMnC,SAAW,GACzCsC,EAAaF,EAAQzF,MAAM,EAAGwF,EAAMlC,WAAWxC,OAAO,GACtD8E,EAAM,GACZ,GAAGH,GAAWA,EAAQ3E,OAAQ,CAC5B6E,EAAW5B,QAAQ,CAACf,EAAM6C,KAExBD,EADYJ,EAAMlC,WAAWuC,IAClB7C,IAEb,MAAM3C,EAASmF,EAAMlC,WAAWxC,OAAS8E,EAAMH,EAAQzF,MAAM,GAC7DuF,GAAa,EACb1F,EAAe2F,EACftE,EAAkBsE,EAAOnF,GACzBgB,EAAUmE,EAAOnF,UAnBhB+B,IAAQgD,IACTG,GAAa,EACb1F,EAAe2F,EACftE,EAAkBsE,EAAO,IACzBnE,EAAUmE,EAAO,OA4BvB,OATID,EAMM5F,GACR6B,QAAQC,IAAI,gBAAiB5B,IAN7BA,EAAe,KACZI,IACEN,GAAO6B,QAAQC,IAAI,YACtBxB,EAAgB2E,KAAKjD,aAU3BmE,UACE,OAAOpG,EAGTE,sBAAsB4F,GACpB,OAAO5F,IAAgB4F,EAKzBrD,oBACE,OAAOzC,EAKTG,0BACE,OAAOA,EAETkG,eACErG,EAAU,GACVE,GAAa,EACbC,EAAe,KACfI,EAAkB,KAClBF,EAAgBD,EAAqBE,MAAM,GAE7CgG,iBAAiBR,GACf7F,IAAW6F,EAKbO,4BAA4BlF,EAAM,IAChCd,EAAcmD,QAAQrC,GACtBd,EAAgBQ,EAAE0F,OAAOlG"}